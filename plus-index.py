'''
Расставьте знаки + между некоторыми цифрами числа 12345678910111213...N, чтобы в сумме получилось число M.
На вход получаем два натуральных числа N и M.
Вывод: верные примеры в строку.
'''
def find_sum(n, m):
    num_str = [str(i) for i in range(1, n+1)]
    results = [] # Список для всех верных вариантов расстановки знака +
    def find_path_recur(start, path): # Функция для рекурсивного поиска вариантов расстановки знаков
        if start == len(num_str): # Если дошли до конца строки
            if eval(path) == m: # Если результат выполнения path как выражения равен m, то добавляем вариант в список с результатами
                results.append(path)
            return
        find_path_recur(start+1, path+num_str[start]) # Пропускаем текущую цифру
        find_path_recur(start+1, path+'+'+num_str[start]) # Вставляем знак + перед последней цифрой
    find_path_recur(1, num_str[0]) # Запускаем поиск вариантов с первой цифры и без знаков
    return results # Возвращаем список всех вариантов

N, M = map(int, input().split())

res = find_sum(N, M)
for r in res:
    print(f'{r}={M}')

'''
Задан массив из чисел a1... aN, требуется найти границы его строго монотонного подотрезка максимальной длины. 
Если их несколько, вывести границы самого левого.
На вход получаем строку с цирфами, разделенными запятой.
Вывод: два числа, которые являются индексами первого и последнего элемента в подотрезке.
'''
m = list(map(int, input().split(',')))
indexes = [[0, 0]] # Для хранения границ всех найденных подотрезков
first_index = 0
for i in range(len(m) - 1):
    if m[i] < m[i + 1] or m[i] > m[i + 1]: # Если отрезок монотонный
        indexes[-1][1] = i + 1 # то записываем индекс последнего элемента в монотонном подотрезке
    else:
        indexes.append([i + 1, i + 1]) # Если монотовнный отрезок закончился, то содаем новую запись с границами подотрезка
res = max(indexes, key=lambda x: x[1] - x[0]) # Вычисляем подотрезок максимальный длины по индексам элементов
print(res[0], res[1])
